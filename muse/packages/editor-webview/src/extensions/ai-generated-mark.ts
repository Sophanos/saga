import { Mark, mergeAttributes } from '@tiptap/core';

export type SuggestionStatus = 'pending' | 'approved' | 'rejected';

export interface AIGeneratedMarkAttributes {
  /** Unique identifier for the suggestion/generation */
  generationId: string | null;
  /** Current status of the suggestion */
  status: SuggestionStatus;
  /** Timestamp when the content was generated */
  createdAt: string | null;
  /** Model that generated the content (e.g., 'claude-sonnet', 'gpt-4o') */
  model: string | null;
  /** Agent ID that triggered the generation */
  agentId: string;
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    aiGenerated: {
      /**
       * Set AI generated mark on selection
       */
      setAIGenerated: (attributes?: Partial<AIGeneratedMarkAttributes>) => ReturnType;
      /**
       * Toggle AI generated mark
       */
      toggleAIGenerated: (attributes?: Partial<AIGeneratedMarkAttributes>) => ReturnType;
      /**
       * Remove AI generated mark
       */
      unsetAIGenerated: () => ReturnType;
      /**
       * Update status of AI generated content by generationId
       */
      updateAIGeneratedStatus: (generationId: string, status: SuggestionStatus) => ReturnType;
    };
  }
}

/**
 * AIGeneratedMark - Tracks content generated by AI agents
 *
 * This mark is applied to any content produced by AI (Muse agent).
 * It tracks:
 * - generationId: Unique ID for the generation session
 * - status: pending | approved | rejected
 * - createdAt: ISO timestamp
 * - model: The AI model used
 * - agentId: Which agent generated it (default: 'muse')
 *
 * Visual states are controlled via CSS classes based on status.
 */
export const AIGeneratedMark = Mark.create<{
  HTMLAttributes: Record<string, unknown>;
}>({
  name: 'aiGenerated',

  addOptions() {
    return {
      HTMLAttributes: {},
    };
  },

  addAttributes() {
    return {
      generationId: {
        default: null,
        parseHTML: (element) => element.getAttribute('data-generation-id'),
        renderHTML: (attributes) => {
          if (!attributes['generationId']) return {};
          return { 'data-generation-id': attributes['generationId'] };
        },
      },
      status: {
        default: 'pending' as SuggestionStatus,
        parseHTML: (element) =>
          (element.getAttribute('data-status') as SuggestionStatus) || 'pending',
        renderHTML: (attributes) => ({
          'data-status': attributes['status'],
        }),
      },
      createdAt: {
        default: null,
        parseHTML: (element) => element.getAttribute('data-created-at'),
        renderHTML: (attributes) => {
          if (!attributes['createdAt']) return {};
          return { 'data-created-at': attributes['createdAt'] };
        },
      },
      model: {
        default: null,
        parseHTML: (element) => element.getAttribute('data-model'),
        renderHTML: (attributes) => {
          if (!attributes['model']) return {};
          return { 'data-model': attributes['model'] };
        },
      },
      agentId: {
        default: 'muse',
        parseHTML: (element) => element.getAttribute('data-agent-id') || 'muse',
        renderHTML: (attributes) => ({
          'data-agent-id': attributes['agentId'],
        }),
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-ai-generated]',
      },
    ];
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'span',
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        'data-ai-generated': 'true',
        class: `ai-generated ai-status-${HTMLAttributes['data-status'] || 'pending'}`,
      }),
      0,
    ];
  },

  addCommands() {
    return {
      setAIGenerated:
        (attributes = {}) =>
        ({ commands }) => {
          const defaults: AIGeneratedMarkAttributes = {
            generationId: attributes.generationId ?? crypto.randomUUID(),
            status: 'pending',
            createdAt: new Date().toISOString(),
            model: null,
            agentId: 'muse',
          };
          return commands.setMark(this.name, { ...defaults, ...attributes });
        },

      toggleAIGenerated:
        (attributes = {}) =>
        ({ commands }) => {
          const defaults: AIGeneratedMarkAttributes = {
            generationId: attributes.generationId ?? crypto.randomUUID(),
            status: 'pending',
            createdAt: new Date().toISOString(),
            model: null,
            agentId: 'muse',
          };
          return commands.toggleMark(this.name, { ...defaults, ...attributes });
        },

      unsetAIGenerated:
        () =>
        ({ commands }) => {
          return commands.unsetMark(this.name);
        },

      updateAIGeneratedStatus:
        (generationId: string, status: SuggestionStatus) =>
        ({ tr, state, dispatch }) => {
          if (!dispatch) return false;

          let updated = false;
          const markType = state.schema.marks[this.name];

          state.doc.descendants((node, pos) => {
            if (!node.isText) return;

            const mark = node.marks.find(
              (m) => m.type === markType && m.attrs['generationId'] === generationId
            );

            if (mark) {
              const newMark = markType.create({
                ...mark.attrs,
                status,
              });

              tr.removeMark(pos, pos + node.nodeSize, markType);
              tr.addMark(pos, pos + node.nodeSize, newMark);
              updated = true;
            }
          });

          if (updated) {
            dispatch(tr);
          }

          return updated;
        },
    };
  },
});

export default AIGeneratedMark;
